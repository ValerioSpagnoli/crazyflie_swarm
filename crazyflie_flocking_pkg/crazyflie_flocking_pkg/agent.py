from typing import Dict, List

import numpy as np

from crazyflie_flocking_pkg.flocking_forces import ForcesGenerator
from crazyflie_flocking_pkg.utils.configuration import FlockingConfig
from crazyflie_flocking_pkg.utils.definitions import (
    Direction,
    Obstacle,
    ObstacleType,
)
from crazyflie_swarm_pkg.crazyflie import CrazyState


class Agent:
    def __init__(self, name: str, config: FlockingConfig):
        self.forces_gen = ForcesGenerator(config)
        self.config = config
        self.name = name
        self.counter = 0
        self.n_cycles_decision = 10
        self.v_mig = np.array([0, 0, 0])

    def compute_velocities(self, swarm_state: Dict[str, CrazyState], target):
        """
        Computes the velocities of the drone based on the forces generated by the flocking algorithm.
        """
        # Get the state of the drone
        state = swarm_state[self.name]

        # Get the state of the neighbors
        neighbors = swarm_state.copy()
        neighbors.pop(self.name)  # remove myself from neighbors

        # TODO: per ora si mettono solo in formazione
        v_mig = np.array([0, 0, 0])

        detected_obstacles = self.detect_obstacles(state, neighbors)

        forces = self.forces_gen.get_forces(
            state, neighbors, detected_obstacles, v_mig
        )
        overall_force = np.sum(forces, axis=1)
        v, omega = self.forces_gen.compute_velocities(
            overall_force, state, neighbors, target
        )

        return v, omega

    def detect_obstacles(
        self, state: CrazyState, neighbors: Dict[str, CrazyState]
    ) -> List[Obstacle]:
        """
        Detects obstacles around the agent based on its state and the states of its neighbors.
        Args:
            state (CrazyState): The current state of the agent, which includes sensor readings.
            neighbors (Dict[str, CrazyState]): A dictionary of neighboring agents' states, keyed by their identifiers.
        Returns:
            List[Obstacle]: A list of detected obstacles, each with its absolute position, relative position, direction, and type.
        The function performs the following steps:
        1. Initializes an empty list to store detected obstacles.
        2. Checks the agent's sensor readings in the front, left, back, right, and up directions.
        If an obstacle is detected within a threshold distance (2 units), it calculates the obstacle's relative position,
        converts it to an absolute position, and appends it to the list of detected obstacles.
        3. Iterates over the detected obstacles to determine their type:
        - If the obstacle is below a certain height (0.1 units), it is classified as a floor.
        - If the obstacle is within a close distance (0.1 units) to any neighbor, it is classified as a drone.
        - Otherwise, it is classified as a generic obstacle.
        4. Returns the list of detected obstacles.
        """
        detected_obstacles: List[Obstacle] = []

        # TODO: 2? li prendiamo tutti?
        if state.mr_front < 2:
            obstacle_rel_pos = state.mr_front * np.array([[1], [0], [0]])
            detected_obstacles.append(
                Obstacle(
                    abs_pos=state.rel2glob(obstacle_rel_pos),
                    direction=Direction.front,
                )
            )

        if state.mr_left < 2:
            obstacle_rel_pos = state.mr_left * np.array([[0], [1], [0]])
            detected_obstacles.append(
                Obstacle(
                    abs_pos=state.rel2glob(obstacle_rel_pos),
                    direction=Direction.left,
                )
            )

        if state.mr_back < 2:
            obstacle_rel_pos = state.mr_back * np.array([[-1], [0], [0]])
            detected_obstacles.append(
                Obstacle(
                    abs_pos=state.rel2glob(obstacle_rel_pos),
                    direction=Direction.back,
                )
            )

        if state.mr_right < 2:
            obstacle_rel_pos = state.mr_right * np.array([[0], [-1], [0]])
            detected_obstacles.append(
                Obstacle(
                    abs_pos=state.rel2glob(obstacle_rel_pos),
                    direction=Direction.right,
                )
            )

        if state.mr_up < 2:
            obstacle_rel_pos = state.mr_right * np.array([[0], [0], [1]])
            detected_obstacles.append(
                Obstacle(
                    abs_pos=state.rel2glob(obstacle_rel_pos),
                    direction=Direction.up,
                )
            )

        self_state = state.get_position()
        for o in detected_obstacles:
            isObstacle = True

            if o.abs_pos[2] < 0.1:
                isObstacle = False
                o.type = ObstacleType.floor
                continue

            for _, neighbor in neighbors.items():
                dist = np.linalg.norm(o.abs_pos - neighbor.get_position())

                if dist < 0.1:
                    isObstacle = False
                    o.type = ObstacleType.drone
                    break

            if isObstacle:
                obstacle_rel_pos = np.linalg.norm(self_state - o.abs_pos)
                o.rel_pos = obstacle_rel_pos
                o.type = ObstacleType.obstacle

        return detected_obstacles
